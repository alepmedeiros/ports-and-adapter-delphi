Inspiracoes
https://www.youtube.com/watch?v=JufRR4GGkgA Base da palestra

https://www.youtube.com/watch?v=DWsxTJpxaOo&t=3s
https://www.youtube.com/watch?v=kCSiGeUFi_U&t=214s

Arquitetura Hexagonal ou ports and adapter

Objetivo é construir aplicações que vão se manter de uma forma melhor ao logo do tempo, nós iremos conseguir baixar o custo da manutenção, o objetivo de ter uma boa arquitetura é justamente ter um software melhor, se você quer construir aplicações de grande porte, em ser um desenvolvedor que de exelencia, é importante apreder esses conceitos.

Você acha que arquitetura hexanonal é indispensavel hoje em dia para o desenvolvimento, ou você acha que ainda consiga construir aplicações sem utilizar esse tipos de arquitetura e tenha uma aplicação sustentável, com baixo custo na manutenção.

Exemplo de um estacionamento, com entrada e saida, calcula o valor a ser pago.

Quando começamos a desenvolver, diante de uma tela em branco, devemos tomar uma decisão qual caminho seguir, é importante que busquemos experiencias profissionais e comecemos algo do zero.

Por que essa experiencia é relevante?

Você irá estar em uma possição, que irá te levar a tomar certas desições, e essas desições tem um custo e um beneficio, então de certa forma, agraga consideralmente na sua carreira.

Vamos para um modelagem simples:

Depomos olhar para caso de uso, que são o que entregamos de fato para o usuário final.

Então vamos lá:

Eu tenho:
	Carro estacionado
Esse carro estacionado, ele entra no estacionamento

domain: 

parked car

uses cases: (algo super neutro) aqui é api que a sua aplicação expoe, não é a api webservice, que você está usando

check-in (placa) ok
checkout (placa) : price
getParkedCars


o correto é começarmos orientado a teste, mas niguem de fato começa a implementar orientado a teste.

as pessoas no dia a dia tem muita necessidade de conectarem as pontas, isso é um mal, muita vezes nós temos essa inclunação de querer ver a coisa funcionando de ponta a ponta, e isso faz com que nós atropelamos as coisas.


começar a implementação que muitos já começam:

criar um projeto do zero, seguindo a ideia rad, e a forma erronea que muitos já fazem

vamos falar um pouco sobre ports and adapters

qual é o grande centro de ports and adapters?

a principal ideia é que você tenha uma aplicação que pode ser guiada por clientes diferentes, esse é um dos pontos.

como é que sou guiado por clientes diferente, eu posso ter uma api, posso ter uma fila, posso ter um CLI, uma user interface, diversos clientes.

Essa aplicação do jeito que está escrita, ela é guiavel por varios cliente? Não, ela só é guiada pela api, regras de negocio estão escritas na api

Quando pensamos em regra de negocio, podemos levar algumas coisas para a api, que é o seguinte:
quando saio com o carro, eu devo localizar, o checkout eu tenho que ideitificar um carro para que eu retorne um preço, pelo tempo que o carro permaneceu parado


===========================================================

Agora chegamos no ponto que queriamos:

repare que temos uma mistura, e para quem pensou em ports and adapter por volta de 1994, isso pode parecer para alguns algo inlusório, e outros já visto, mas isso acontece em diferentes niveis, na interface grafica, dentro de uma api, dentro de um package.

a ideia é que sua aplicação guiasse dispositivos de IO de forma mais livre, não deveria estar acoplado a um banco de dados especifico.

e nesse momento eu possuo dois problemas, eu não posso testar no nivel de application, pois fico amarrado a api, a um client, não podendo variar o dispositivo de entrada e saida, porque tenho a regra de negocio acoplada.

Esse é um territorio muito fertil para que possamos explorar, e agora podemos refatorar rumo a ports and adapter

=============================================================

Primeira coisa que tenho q fazer, qual é o usecase


domain: 

parked car

uses cases: (algo super neutro) aqui é api que a sua aplicação expoe, não é a api webservice, que você está usando

check-in (placa) ok
checkout (placa) : price
getParkedCars

é o checking.

a partir desse momento eu mudo completamente a interface, porque agora eu posso ter um checking de teste, não mais por meio de um client especifico, mas pela camada de aplicação, na borda do hexagono.
Se pensarmos no hexagono, as bordas que ele tem, uma delas é o checking